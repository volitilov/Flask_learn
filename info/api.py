api :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# документация интерфейса flask

# документация на английском:
# http://flask.pocoo.org/docs/0.12/api/

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

from flask import *

# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Flask(import_name, static_path=None, static_url_path=None, 
	static_folder='static', template_folder='templates', 
	instance_path=None, instance_relative_config=False, 
	root_path=None)
#
	import_name
	# имя пакета приложения

	static_url_path
	# может использоваться для указания другого пути для статических 
	# файлов в Интернете. По умолчанию указывается имя папки static_folder.

	static_folder
	# папку со статическими файлами, которая должна быть отправлена ​​на 
	# static_url_path. По умолчанию устанавливается 'static' папка в 
	# корневом пути приложения.

	template_folder
	# папку, содержащую шаблоны, которые должны использоваться приложением. 
	# По умолчанию используется папка 'templates' в корневом пути приложения.



add_template_filter(f, name=None)
# Регистрирует настраиваемый фильтр шаблонов. Работает точно так же, как 
# декоратор template_filter().

add_template_global(f, name=None)
# Регистрирует глобальную функцию настраиваемого шаблона. Работает точно так 
# же, как декоратор template_global()

add_template_test(f, name=None)
# Регистрирует пользовательский шаблонный тест. Работает точно так же, как 
# декоратор template_test()

add_url_rule(rule, endpoint=None, view_func=None, **options)
# создаёт асоциацивный привязку функции к URL-адресу аналог декаратора
# route()
	rule
	# URL как строка
	endpoint
	# указывает точку входа, тоесть название для функции в виде строки
	view_func
	# указывает функцию привязки


after_request(f)
# регестрирует функцию для вызова после обработки каждого запроса, если не 
# возникло необработанных исключений

after_request_funcs = None
# Словарь со списком функций, которые должны вызываться после каждого запроса. 
# Ключ словаря - это название плана, для которого эта функция активна, 
# None для всех запросов. Это можно, например, использовать для закрытия 
# соединений с базой данных. Чтобы зарегистрировать функцию в даный список, 
# используйте декоратор after_request()

app_context()
# получение контест приложения вызвав метод в экзепляре приложения

auto_find_instance_path()
# Пытается найти путь к экземпляру, если он не был предоставлен конструктору 
# класса приложения. Он будет в основном вычислять путь к папке с именем 
# 'instance' рядом с вашим основным файлом или пакетом.

before_first_request(f)
# Регистрирует функцию, которая должна быть запущена до первого запроса к 
# этому экземпляру приложения. Функция будет вызываться без каких-либо 
# аргументов, и ее возвращаемое значение игнорируется.

before_first_request_funcs = None
# Списки функций, которые должны быть вызваны в начале первого запроса к 
# этому экземпляру. Чтобы зарегистрировать функцию в даный список, используйте 
# декоратор before_first_request().

before_request(f)
# Регистрирует функцию, выполняемую перед каждым запросом. Функция будет 
# вызываться без каких-либо аргументов. Если функция возвращает значение, 
# отличное от None, оно обрабатывается так, как если бы это было возвращаемое 
# значение из представления, и обработка запроса прекращается.

before_request_funcs = None
# Словарь со списками функций, которые должны быть вызваны в начале запроса. 
# Ключ словаря - это название плана, для которого эта функция активна, 
# None для всех запросов. Это можно, например, использовать для открытия 
# соединений с базой данных или получения текущего пользователя. Чтобы здесь 
# зарегистрировать функцию, используйте декоратор before_request()

blueprints = None
# словарь с blueprint

config = None
# Словарь конфигурации как Config. Это ведет себя как обычный словарь, но 
# поддерживает дополнительные методы для загрузки конфигурации из файлов.

context_processor(f)
# Регистрирует функцию контекстного процессора шаблона.

create_global_jinja_loader()
# 

create_jinja_environment()
# 

create_url_adapter(request)
# Создает адаптер URL для данного запроса. Адаптер URL-адреса создается в 
# точке, где контекст запроса еще не настроен, поэтому запрос передается
# явно.

debug=True
# включает отладку приложения

full_dispatch_request()
# Отправляет запрос и, кроме того, выполняет предварительную и постпроцессию 
# запроса, а также обработку исключений HTTP и ошибок.

error_handler_spec = None
# Словарь всех зарегистрированных обработчиков ошибок. Ключ None для 
# обработчиков ошибок, активных в приложении, иначе ключ - это название 
# blueprint. Каждый ключ указывает на другой словарь, в котором ключ 
# является кодом состояния исключения http. Специальный ключ None указывает 
# на список кортежей, где первый элемент является классом для проверки 
# экземпляра, а второй - обработчиком ошибок.
# Пример: app.error_handler_spec[None][404] = func_name 

extensions = None
# место, где расширения могут сохранять состояние приложения. Например, в 
# этом случае расширение может хранить базы данных и подобные вещи. Для 
# обратной совместимости расширения должны регистрироваться следующим 
# образом:
# if not hasattr(app, 'extensions'):
# 	app.extensions = {}
# app.extensions['extensionname'] = SomeObject()

get_send_file_max_age(filename)
#

got_first_request
# Для этого атрибута устанавливается значение True, если приложение начало 
# обрабатывать первый запрос.

handle_exception(e)
# Обработка исключений по умолчанию, срабатывающая при возникновении 
# исключения, которое не было обнаружено. В режиме отладки исключение будет 
# повторно поднято немедленно, в противном случае оно будет зарегистрировано 
# и обработчик для внутренней ошибки сервера 500. Если такой обработчик не 
# существует, отображается сообщение об ошибке внутреннего сервера 
# по умолчанию 500.

handle_http_exception(e)
#



redirect()
#

abort()
#

make_response()
#

request()
#

url_for()
#

render_template()
#